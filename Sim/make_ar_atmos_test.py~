import numpy as np
import numpy.random as ra
import scipy.fftpack as sf
import pyfits as pf
import generate_grids as gg
import argparse
from datetime import datetime

def make_ar_atmos(exptime, rate, alpha_mag, n, m, nofroflo=False, dept=False, r0=0.14, v=16.5):   
    """
    ######################
    ## Srikar Srinath - 2015-02-06
    ## Makes an multi-layer frozen flow atmosphere with boiling sized for the
    ## telescope parameters in the first few lines of the program
    ## Inputs:
    ##       exptime   - (float) exposure time in seconds
    ##       rate      - (float) optical system rate/cadence in Hertz (Gemini uses 1500 Hz)
    ##       alpha_mag - magnitude of autoregressive alpha parameter
    ##                   (1 - alpha_mag) determines fraction of phase from
    ##                   prior timestep that is "forgotten" e.g. 
    ##                   alpha_mag = 0.9 implies 10% forgotten
    ##                   set to a list for multi-layer atmosphere - might be better to
    ##                   just add this to the cp_params array below?
    ##       n         - number of subapertures across screen (not the
    ##                   number of subapertures across the aperture, which
    ##                   is less than this number)
    ##       m         - number of pixels per subaperture (Gemini sim uses n=48, m=8)
    ## Flags:
    ##        nofroflo - flag that gives a "boiling only" atmosphere if True
    ##                   i.e. all frozen flow velocities set to 0
    ##        dept     - depiston and detilt the output and impose the
    ##                   aperture
    ##        hdf5     - Save to HDF5 format instead
    ##        compare  - compare RMS of AR phase with random phase screens
    ##                   generated by other methods - screengen, pure
    ##                   frozen flow, random uncorrelated. Only for use
    ##                   with one layer case. 
    ## Outputs:
    ##        phase    - fits file with bign x bign x timesteps
    """

    rootdir = './'

    # filnename root for a multilayer simulation-worthy datacube
    arfileroot = rootdir+"aratmos_rate{0}_exptime{1}_r0{2}_v{3}".format(np.round(rate), exptime, r0, v)
    layerfileroot = arfileroot+'-layer'

    ## telescope geometry - Gemini for now. Move to structure for
    bigD  = 8.4               ## primary diameter - 7.7 for Gemini, 8.4 for LSST
    bigDs = 3                 ## inner M2 is 1.024 m

    ## derived quantities
    bign      = n*m               ## width of phase screen for aperture

    ## for phase samples
    pscale    = bigD/(n*m) ## pixel size (m) of samples in pupil plane
    d         = pscale*m   ## subap diameter (m)

    ### make the aperture to impose later if desired
    ax, ay    = gg.generate_grids(bign, scalefac=pscale)
    ar        = np.sqrt(ax**2 + ay**2) ## aperture radius
    ap_outer  = (ar <= bigD/2)
    ap_inner  = (ar <= bigDs/2)   
    aperture  = (ap_outer - ap_inner).astype(int)

    timesteps = exptime * rate #np.floor(exptime * rate)   ## number of timesteps 

    # create atmosphere parameter array, 
    #                      ( r0,     vel,    dir, alt] x n_layers
    #                      meters,   m/s,degrees (0-360), meters
    cp_params = np.array([
                         (0.40	,    6.9	,284,  0		),
                         (0.78	,    7.5	,267,  25		),
                         (1.07	,    7.8	,244,  50		),
                         (1.12	,    8.3	,267,  100		),
                         (0.84	,    9.6	,237,  200		),
                         (0.68	,    9.9	,232,  400		),
                         (0.66	,    9.6	,286,  800		),
                         (0.91	,    10.1	,293,  1600		),
                         (0.40	,    7.2	,270,  3400		),
                         (r0	,    v   ,269,  6000		),
                         (0.85	,    23.2	, 59,  7600		),
                         (1.09	,    32.7	,259,  13300	),
                         (1.08	,    5.7	,320,  16000	)
                         ])
    ##################################################################################
    ## The following is to generate 3 layers to mimic median conditions
#    n_layers  = 3
#
#    layer1 = [0, 1, 3, 6, 7, 8, 12]
#    layer1dom = 0
#
#    layer2 = [2, 4, 5]
#    layer2dom = 5
#
#    layer3 = [9, 10, 11]
#    layer3dom = 10
#
#    fullr0s       = cp_params[:,0]              ## r0 in meters
#    r0s = np.array([(fullr0s[layer1]**(-5./3.)).sum()**(-3./5.), 
#                    (fullr0s[layer2]**(-5./3.)).sum()**(-3./5.),
#                    (fullr0s[layer3]**(-5./3.)).sum()**(-3./5.)])
#
#    fullvels      = cp_params[:,1]              ## m/s,  set to 0 to get pure boiling
#    vels = np.array([fullvels[layer1dom], fullvels[layer2dom], fullvels[layer3dom]])
#
#    if nofroflo: 
#        vels = vels * 0.0
#    fulldirs      = cp_params[:,2] * np.pi/180. ## in radians
#    dirs = np.array([fulldirs[layer1dom], fulldirs[layer2dom], fulldirs[layer3dom]])
    #####################################################################################

    n_layers = 1
    r0s = np.array([r0])
    vels = np.array([v])
    dirs = np.array([0]) ## all in the x-direction

    ## decompose velocities into components
    vels_x    = vels * np.cos(dirs)
    vels_y    = vels * np.sin(dirs)
    
    # generate spatial frequency grids
    screensize_meters = bign * pscale
    deltaf = 1./screensize_meters           ## spatial frequency delta
    fx, fy = gg.generate_grids(bign, scalefac=deltaf, freqshift=True)
    print fx[0], fx[47]

    phase = np.zeros((bign,bign,n_layers,timesteps),dtype=float)
    phFT  = np.zeros((bign,bign,n_layers,timesteps),dtype=complex)  ## array for FT of phase

    print "Atmosphere conditions set."

    for i in np.arange(n_layers):
        # Set the noise scaling powerlaw - the powerlaw below if from Johansson & Gavel 1994 for a 
        # Kolmogorov screen
        powerlaw = (2*np.pi*np.sqrt(0.00058)*(r0s[i]**(-5.0/6.0))*
                    (fx**2. + fy**2.)**(-11.0/12.0)*bign*np.sqrt(np.sqrt(2.))/screensize_meters)
        powerlaw[0,0] = 0.0
        ## make array for the alpha parameter and populate it
        alpha_phase = - 2 * np.pi * (fx*vels_x[i] + fy*vels_y[i]) / rate
        alpha = alpha_mag * (np.cos(alpha_phase) + 1j * np.sin(alpha_phase))

        noisescalefac = np.sqrt(1 - (np.abs(alpha))**2)
        print 'Layer', str(i+1), 'alpha created'
      
        for t in np.arange(timesteps):
             # generate noise to be added in, FT it and scale by powerlaw
             noise = np.random.randn(bign,bign)

             ## no added noise yet, start with a regular phase screen
             noiseFT = sf.fft2(noise) * powerlaw

             if t == 0:
                 wfFT = noiseFT
                 phFT[:,:,i,t] = noiseFT
             else:      
             # autoregression AR(1)
             # the new wavefront = alpha * wfnow + noise
                 wfFT = alpha * phFT[:,:,i,t-1] + noiseFT * noisescalefac
                 phFT[:,:,i,t] = wfFT
            
             # the new phase is the real_part of the inverse FT of the above
             wf = sf.ifft2(wfFT).real
 
             # impose aperture, depiston, detilt, if desired
             if dept:
                 import depiston as dp
                 import detilt as dt
                 phase[:,:,i,t] = depiston(detilt(wf,aperture),aperture)*aperture
             else:
                 phase[:,:,i,t] = wf
        
#        print 'Writing layer', str(i+1), 'file'  
#        phase[:,:,i,:].shape 
#        hdu = pf.PrimaryHDU(phase[:,:,i,:].transpose())
#        hdu.writeto(layerfileroot+str(i+1)+'.fits', clobber=True)
        print 'Done with Layer', str(i+1)

    phaseout = np.sum(phase, axis=2)  # sum along layer axis
    hdu = pf.PrimaryHDU(phaseout.transpose())
    hdu.writeto(arfileroot+'.fits', clobber=True)
    print 'Done'

if __name__ == '__main__':  

    parser = argparse.ArgumentParser()
    parser.add_argument("exptime", default=15, type=float)
    parser.add_argument("rate", default=1000, type=float)
    parser.add_argument("alpha_mag", default=0.999, type=float)
    parser.add_argument("n", default=48, type=int)
    parser.add_argument("m", default=1, type=int)
    parser.add_argument("-f", "--nofroflo", default=False, type=bool)
    parser.add_argument("-d", "--dept", default=False, type=bool)  
    parser.add_argument("-v", "--velocity", default=16.5, type=float)
    parser.add_argument("-r", "--r0", default=0.5, type=float)

    args = parser.parse_args()

    exptime = args.exptime
    rate = args.rate
    alpha_mag = args.alpha_mag
    n = args.n
    m = args.m
    nofroflo = args.nofroflo
    dept = args.dept
    v = args.velocity
    r0 = args.r0

    make_ar_atmos(exptime, rate, alpha_mag, n, m, nofroflo, dept, r0, v) 

